*****************************************************************

Jon's Work Logs for Apr 4, 2018

*****************************************************************

I still think this for comprehension, at least for containers is a little bit of a confusing syntax
```scala
def prepareCappuccino(): Try[Cappuccino] = for {
  ground <- Try(grind("arabica beans"))
  water <- Try(heatWater(Water(25)))
  espresso <- Try(brew(ground, water))
  foam <- Try(frothMilk("milk"))
} yield combine(espresso, foam)
```

# Scala Concurrency

We want to do some tasks parallely, without blocking on things like network requests, I/O, database q

Node.js uses callbacks, but those have the problem of inversion of control/ unreadability (callback hell)

# Future type

Scala uses a container type `Future[T]`, which sounds like it is comoparable to a JS promise

* The Future will resolve to type T, but it may also contain an exceptiona well
* Future is write-once, once the Future is completed, the container is immutable and only provides an interface for reading the value
* `Promise` type is responsible for actually writing the value to the Future, which separates concerns

**NOTE** In Scala you can't define type aliases outside a class/ object/ trait

I've been playing around with Futures and I think I understand them kinda at a high level, but actually writing them is still kind of a pain.  In a way that's how I felt with JS promises at first, and it is good to have these alternate ways of looking at problems such as concurrency.

# Promise type

I still feel like there is something im missing in my understanding of the Future type, maybe the Promise type will enlighten me somewhat.

A Promise is a companion type that allows you to write exactly once to a Future

Each Promise has a 1:1 relationship with an instance of Future

This can be implemented either by two different objects or a single object that implements both traits


*****************************************************************

Jon's Work Logs for Mar 19, 2018

*****************************************************************

Floating number types in Java

Float is 32-bit, while Double is 64-bit number, the different is the accuracy
Rule of thumb: use floats when memory usage is critical versus double for precise
computations

A float gives you approx 6-7 decimal digits precision while a double gives you approx 15-16 digits

Long is a 64 bit signed integer, not a floating point number

**Data Representation on Computers**

Based on [this](https://www.ntu.edu.sg/home/ehchua/programming/java/DataRepresentation.html)

Computers use binary (base 2), or hexadecimal (base 16) or octal (base 8) number for compact forms

**binary**
A binary digit is called a bit, Eight bits is a byte.

Some languages denote binary numbers with prefix `0b` like this `0b100110`

**hexadecimal**
Some languages denote hex with prefix `0x` like `0x1AC5F`

Each hexadecimal digit is something from 0-9 or a-f (learned this from my Google interview)

Although computers will represent numbers as binary internally, we can use hexadecimals as an
abstraction to make reading/ writing numbers easier.

Each hex is equivalent to 4 binary bits (which can represent numbers from 0-15)
i.e.
```
hex 0 = b0000
hex 3 = b0011
hex 15 = b1111
```

**computer memory representation**
A computer must use a fixed number of bits to rep a piece of data.
An n-bit storage can represent up to 2^n positions

**integers**
signed number means that the number has either an positive or negative sign (not as I previously believed that it has some kind of cryptographic checksum)

i.e. an 8-bit number can represent up to 256 positions.

If unsigned, it can rep 0-255

If I include a sign bit then it can represent between -128 and 127

**takeaway**
The computer just implements data in binary, it has no meaning until your program decides upon a meaning
based on an encoding scheme that can convert data types to binary and back.

**ways to represent signed integers**

1. Sign magnitude: just have first integer be zero if positive, 1 if negative.

The drawback is that you have two representations for 0 (pos 0 and negative 0) which is wasteful and
confusing.  And you then have to "sign" and integer after you compute it's absolute value

2. 1's complement representation: negative is complement for positive (i.e. switch each bit to complement of what it is)

Same two drawbacks of double representing 0 and processing pos/neg separately

3. 2's complement representation:
Basically same as 1's complement but add 1 if negative

So 111B => -1D * (000B + 1D) = 0D - 1D = -1D

Allows you to not double represent 0, allows you to add/ subtract binary integers

Idea: it would be cool to create binary calculator for scratch

** Weapons of Math Destruction**
One reason that algorithms that rank people as good teachers or good credit risks are flawed is because
there is no feedback mechanism when the system is flawed, people can't contest decisions that the model
gave